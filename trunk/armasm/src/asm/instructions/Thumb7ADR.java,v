head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2003.02.07.18.18.41;	author hans;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Thumb7 support update
@
text
@package asm.instructions;

import java.util.Vector;

/**
 * ADR ARM pseudo-instruction
 * Load a program-relative or register-relative address into a register.
 *
 * Syntax
 * ADR{cond} register,expr
 *
 * where:
 * cond is an optional condition code.
 *
 * register is the register to load.
 *
 * expr is a program-relative or register-relative expression that evaluates to:
 * ¥ a non word-aligned address within ±255 bytes
 * ¥ a word-aligned address within ±1020 bytes.
 *
 * More distant addresses can be used if the alignment is 16 bytes or more.
 * The address can be either before or after the address of the instruction or
 * the base register
 **/

public class Thumb7ADR extends Thumb7Instruction {
    
    private Instruction i;
    public Thumb7ADR(ParsedInstruction pi) {
        super(pi);
        Vector opcodes = pi.getOpcodes();
        String rd = (String)opcodes.elementAt(1);
        int destaddr = parseExpression( (String)opcodes.elementAt(2) );
        int pc = pi.getAddress() + 4;
        /*
            start MOV r0,#10
            ADR r4,start ; => SUB r4,pc,#0xc
         */
        
        if ( destaddr < pc ) {
            error("Thumb ADR: offset must be positive -> " + (String)opcodes.elementAt(2));
        } else {
            String cmd = "ADD";
            String offset = "#" + String.valueOf(destaddr - pc);            
            opcodes = new Vector();
            opcodes.addElement(cmd);
            opcodes.addElement(rd);
            opcodes.addElement("r15");
            opcodes.addElement(offset);
            
            i = new Thumb7ADD(new ParsedInstruction(pi.getHandler(), pi.getLineNum(),
            pi.getAddress(), cmd, opcodes));
        }
        
    }
    
    public int getMachineCode() {
        return i.getMachineCode();
    }
}
@
